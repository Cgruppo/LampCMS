<?php
/**
 *
 * License, TERMS and CONDITIONS
 *
 * This software is lisensed under the GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * Please read the license here : http://www.gnu.org/licenses/lgpl-3.0.txt
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * ATTRIBUTION REQUIRED
 * 4. All web pages generated by the use of this software, or at least
 * 	  the page that lists the recent questions (usually home page) must include
 *    a link to the http://www.lampcms.com and text of the link must indicate that
 *    the website\'s Questions/Answers functionality is powered by lampcms.com
 *    An example of acceptable link would be "Powered by <a href="http://www.lampcms.com">LampCMS</a>"
 *    The location of the link is not important, it can be in the footer of the page
 *    but it must not be hidden by style attibutes
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * This product includes GeoLite data created by MaxMind,
 *  available from http://www.maxmind.com/
 *
 *
 * @author     Dmitri Snytkine <cms@lampcms.com>
 * @copyright  2005-2011 (or current year) ExamNotes.net inc.
 * @license    http://www.gnu.org/licenses/lgpl-3.0.txt GNU LESSER GENERAL PUBLIC LICENSE (LGPL) version 3
 * @link       http://www.lampcms.com   Lampcms.com project
 * @version    Release: @package_version@
 *
 *
 */


namespace Lampcms\Category;

use Lampcms\Registry;

/**
 * Class for rendering
 * various html strings
 * from array of categories.
 * Used for making drop-down menu
 * with categories,
 * breadcrumb naviations,
 * html for nested <ul><li> for the
 * HTML of sub-categories
 * for one category for the
 * 'categories' block of the category page view
 *
 * @author Dmitri Snytkine
 *
 */
class Renderer
{
	/**
	 * Registry object
	 *
	 * @var Object of type Lampcms\Registry
	 */
	protected $Registry;

	protected $aCategories;

	protected $ul = '';

	/**
	 * Id of category
	 * this should be rendered as "selected"
	 * inside the categories menu html
	 *
	 * @var int
	 */
	protected $selectedId;

	/**
	 * Constructor
	 * @param Registry $Registry
	 */
	public function __construct(Registry $Registry){
		$this->Registry = $Registry;
		$cur = $Registry->Mongo->CATEGORY->find(array())->sort(array('i_parent' => 1, 'i_weight' => 1));
		/**
		 * Rekey the array so that array keys
		 * are category id
		 */
		foreach($cur as $item){
			//echo "\n<br>id: ".$item['_id'];
			$this->aCategories[$item['_id']] = $item;
		}
		
		d('$this->aCategories: '.print_r($this->aCategories, 1));

	}

	public function getCategories(){
		return $this->aCategories;
	}

	/**
	 * If passed array of category data
	 * has 'a_sub' key with array of sub-categories
	 * then add an extra element ['childred'] to it
	 * and populate with arrays of normalized
	 * category data
	 *
	 *
	 * @param int category id
	 *
	 * @return array, which may have tested
	 * array of children, each child may have nested children, etc.
	 */
	public function getNormalizedCategory($id){
		$ret = $this->aCategories[$id];

		if( !empty($ret['a_sub']) ){
			$tmp = array();
			foreach($ret['a_sub'] as $subId){
				$tmp[] = $this->getNormalizedCategory($subId);
			}

			$children = \array_sort($tmp, function($v, $a){

			});

			unset($ret['a_sub']);
			$ret['children'] = $children;

		}

		return $ret;
	}

	protected function getTopLevel(){
		echo 'getting top level ';
		$ret = array();
		foreach($this->aCategories as $id => $c){
			if(empty($c['i_parent'])){
				echo ' got one '.$id.' ';
				$ret[$id] = $c;
			}
		}

		return $ret;
	}


	public function getByFilter($func){
		$a = array_filter($this->aCategories, $func);

		return $a;
	}

	/**
	 * Get Array of Categories by array of categori ids
	 *
	 * @param array $ids
	 */
	protected function getByIds(array $ids){
		$ret = array();
		foreach($this->aCategories as $id => $c){
			if(in_array($c['_id'], $ids)) {
				$ret[$id] = $c;
			}
		}

		return $ret;
	}

	/**
	 * HTML for the nested sortable
	 * page
	 *
	 * @param array $ids
	 *
	 * @todo pass function as input. The function will be used
	 * as array_filter function. It will be passed to array_filter
	 * on the $this->aCategories and will return array
	 * of categories to iterate over "this time"
	 * This function may then recurse but pass different
	 * function so a different set of categories are selected
	 * (usually child nodes of the currently processed category)
	 * That callback function will be a closure, encapsulating
	 * the value of a_sub array of the currently processed category
	 */
	public function getSortableList($func = null){
		$olStart = '';
		$olEnd = '';

		if(is_callable($func)){
		 $olStart = "\n<ol class=\"sub\">";
		 $olEnd = '</ol>';
		} else {
			$func = function($var){
				return ($var['i_parent'] === 0);
			};
		}

		$a = array_filter($this->aCategories, $func);

		$ret = "\n$olStart";

		foreach($a as $cat){
			$subList = '';
			if(!empty($cat['a_sub'])){
				$subs = $cat['a_sub'];
				$pid = 	$cat['_id'];
				d('pid: '.var_export($pid, true).' has subs: '.print_r($subs, 1));
				$func = function($var) use($subs, $pid) {
					return (in_array($var['_id'], $subs) && (array_key_exists('i_parent', $var))  &&  ($var['i_parent'] === $pid)); //&& (array_key_exists('i_parent', $var))  &&  ($var['i_parent'] === $pid)
				};

				$cat['subs'] = $this->getSortableList($func);
			}

			$ret .= "\n".\tplSortedCategory::parse($cat);
		}

		$ret .= "\n$olEnd";

		return $ret;
	}

	/**
	 * Get HTML for the breadcrumn of the category
	 *
	 * @param int $categoryId
	 */
	public function getBreadCrumb($categoryId){

	}

	/**
	 * Get HTML of the select menu
	 * with categories
	 *
	 * @return html of the select input
	 */
	public function getSelectMenu($selected = 0, $id = "categories_menu"){
		if(!is_int($selected)){
			throw new \InvalidArgumentException('Invalid type of $selected param. Must be int, was: '.gettype($selected));
		}

		$this->selectedId = $selected;
		$ul = "\n<select id=\"$id\" class=\"csmenu\">";
		foreach($this->aCategories as $category){
			if(0 === $category['i_parent']){
				$ul .= $this->getSelectOption($category);
			}
		}

		$ul .= "\n<select>";

		return $ul;
	}


	public function getSelectOption(array $category, $level = 0){
		$tpl = "\n".'<option value="%s"%s>%s</option>';
		$selected = '';
		$title = $category['title'];

		if($this->selectedId === $category['_id']){
			$selected = ' selected="selected"';
		}

		$title = str_repeat("&nbsp;&nbsp;&nbsp;", $level).$title;

		$ret = \sprintf($tpl, $category['_id'], $selected, $title);
		if(!empty($category['a_sub'])){
			foreach($category['a_sub'] as $id){
				$ret .= $this->getSelectOption($this->aCategories[$id], ($level + 1));
			}
		}

		return $ret;
	}

	/**
	 * Get array of categories whose parent id is
	 * $id and also sort then by 'weight'
	 *
	 *
	 * @param unknown_type $id
	 */
	public function getSubCategoriesOf($id){
		$ret = array();
		$tmp = array();
		foreach($this->aCategories as $cat){
			if($cat['i_parent'] == $id){
				$tmp[] = $cat;
			}
		}

	}


}

